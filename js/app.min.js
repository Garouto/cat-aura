;(() => {
  const t = {}

  function e() {
    if (location.hash) return location.hash.replace("#", "")
  }
  let o = !0,
    a = (t = 500) => {
      if (o) {
        const e = document.querySelectorAll("[data-lp]")
        setTimeout(() => {
          e.forEach((t) => {
            t.style.paddingRight = ""
          }),
            (document.body.style.paddingRight = ""),
            document.documentElement.classList.remove("lock")
        }, t),
          (o = !1),
          setTimeout(() => {
            o = !0
          }, t)
      }
    },
    s = (t = 500) => {
      if (o) {
        const e = document.querySelectorAll("[data-lp]"),
          a = window.innerWidth - document.body.offsetWidth + "px"
        e.forEach((t) => {
          t.style.paddingRight = a
        }),
          (document.body.style.paddingRight = a),
          document.documentElement.classList.add("lock"),
          (o = !1),
          setTimeout(() => {
            o = !0
          }, t)
      }
    }

  function n() {
    a(), document.documentElement.classList.remove("menu-open")
  }

  function c(t) {
    setTimeout(() => {
      window.FLS && console.log(t)
    }, 0)
  }

  function r(t) {
    return t.filter((t, e, o) => o.indexOf(t) === e)
  }
  t.watcher = new (class {
    constructor(t) {
      ;(this.config = Object.assign(
        {
          logging: !0,
        },
        t,
      )),
        this.observer,
        !document.documentElement.classList.contains("watcher") && this.scrollWatcherRun()
    }
    scrollWatcherUpdate() {
      this.scrollWatcherRun()
    }
    scrollWatcherRun() {
      document.documentElement.classList.add("watcher"),
        this.scrollWatcherConstructor(document.querySelectorAll("[data-watch]"))
    }
    scrollWatcherConstructor(t) {
      if (t.length) {
        this.scrollWatcherLogging(`Прокинувся, стежу за об'єктами (${t.length})...`),
          r(
            Array.from(t).map((t) => {
              if ("navigator" === t.dataset.watch && !t.dataset.watchThreshold) {
                let e
                t.clientHeight > 2 ? ((e = window.innerHeight / 2 / (t.clientHeight - 1)), e > 1 && (e = 1)) : (e = 1),
                  t.setAttribute("data-watch-threshold", e.toFixed(2))
              }
              return `${t.dataset.watchRoot ? t.dataset.watchRoot : null}|${t.dataset.watchMargin ? t.dataset.watchMargin : "0px"}|${t.dataset.watchThreshold ? t.dataset.watchThreshold : 0}`
            }),
          ).forEach((e) => {
            const o = e.split("|"),
              a = {
                root: o[0],
                margin: o[1],
                threshold: o[2],
              },
              s = Array.from(t).filter((t) => {
                const e = t.dataset.watchRoot ? t.dataset.watchRoot : null,
                  o = t.dataset.watchMargin ? t.dataset.watchMargin : "0px",
                  s = t.dataset.watchThreshold ? t.dataset.watchThreshold : 0
                if (String(e) === a.root && String(o) === a.margin && String(s) === a.threshold) return t
              }),
              n = this.getScrollWatcherConfig(a)
            this.scrollWatcherInit(s, n)
          })
      } else this.scrollWatcherLogging("Сплю, немає об'єктів для стеження. ZzzZZzz")
    }
    getScrollWatcherConfig(t) {
      const e = {}
      if (
        (document.querySelector(t.root)
          ? (e.root = document.querySelector(t.root))
          : "null" !== t.root && this.scrollWatcherLogging(`Эмм... батьківського об'єкта ${t.root} немає на сторінці`),
        (e.rootMargin = t.margin),
        !(t.margin.indexOf("px") < 0 && t.margin.indexOf("%") < 0))
      ) {
        if ("prx" === t.threshold) {
          t.threshold = []
          for (let e = 0; e <= 1; e += 0.005) t.threshold.push(e)
        } else t.threshold = t.threshold.split(",")
        return (e.threshold = t.threshold), e
      }
      this.scrollWatcherLogging("йой, налаштування data-watch-margin потрібно задавати в PX або %")
    }
    scrollWatcherCreate(t) {
      console.log(t),
        (this.observer = new IntersectionObserver((t, e) => {
          t.forEach((t) => {
            this.scrollWatcherCallback(t, e)
          })
        }, t))
    }
    scrollWatcherInit(t, e) {
      this.scrollWatcherCreate(e), t.forEach((t) => this.observer.observe(t))
    }
    scrollWatcherIntersecting(t, e) {
      t.isIntersecting
        ? (!e.classList.contains("_watcher-view") && e.classList.add("_watcher-view"),
          this.scrollWatcherLogging(`Я бачу ${e.classList}, додав клас _watcher-view`))
        : (e.classList.contains("_watcher-view") && e.classList.remove("_watcher-view"),
          this.scrollWatcherLogging(`Я не бачу ${e.classList}, прибрав клас _watcher-view`))
    }
    scrollWatcherOff(t, e) {
      e.unobserve(t), this.scrollWatcherLogging(`Я перестав стежити за ${t.classList}`)
    }
    scrollWatcherLogging(t) {
      this.config.logging && c(`[Спостерігач]: ${t}`)
    }
    scrollWatcherCallback(t, e) {
      const o = t.target
      this.scrollWatcherIntersecting(t, o),
        o.hasAttribute("data-watch-once") && t.isIntersecting && this.scrollWatcherOff(o, e),
        document.dispatchEvent(
          new CustomEvent("watcherCallback", {
            detail: {
              entry: t,
            },
          }),
        )
    }
  })({})
  const i = (t, e = !1, o = 500, a = 0) => {
      const s = document.querySelector(t)
      if (s) {
        let r = "",
          i = 0
        if (e) {
          r = "header.header"
          const t = document.querySelector(r)
          t.classList.contains("_header-scroll")
            ? (i = t.offsetHeight)
            : ((t.style.cssText = "transition-duration: 0s;"),
              t.classList.add("_header-scroll"),
              (i = t.offsetHeight),
              t.classList.remove("_header-scroll"),
              setTimeout(() => {
                t.style.cssText = ""
              }, 0))
        }
        const l = {
          speedAsDuration: !0,
          speed: o,
          header: r,
          offset: a,
          easing: "easeOutQuad",
        }
        const SmoothScroll = window.SmoothScroll
        if ("undefined" != typeof SmoothScroll) new SmoothScroll().animateScroll(s, "", l)
        else {
          let t = s.getBoundingClientRect().top + scrollY
          ;(t = i ? t - i : t),
            (t = a ? t - a : t),
            window.scrollTo({
              top: t,
              behavior: "smooth",
            })
        }
        c(`[gotoBlock]: Юхуу...їдемо до ${t}`)
      } else c(`[gotoBlock]: Йой... Такого блоку немає на сторінці: ${t}`)
    },
    l = !1
  setTimeout(() => {
    if (l) {
      const t = new Event("windowScroll")
      window.addEventListener("scroll", (e) => {
        document.dispatchEvent(t)
      })
    }
  }, 0)
  ;new (class {
    constructor(t) {
      this.type = t
    }
    init() {
      ;(this.оbjects = []),
        (this.daClassname = "_dynamic_adapt_"),
        (this.nodes = [...document.querySelectorAll("[data-da]")]),
        this.nodes.forEach((t) => {
          const e = t.dataset.da.trim().split(","),
            o = {}
          ;(o.element = t),
            (o.parent = t.parentNode),
            (o.destination = document.querySelector(`${e[0].trim()}`)),
            (o.breakpoint = e[1] ? e[1].trim() : "767.98"),
            (o.place = e[2] ? e[2].trim() : "last"),
            (o.index = this.indexInParent(o.parent, o.element)),
            this.оbjects.push(o)
        }),
        this.arraySort(this.оbjects),
        (this.mediaQueries = this.оbjects
          .map(({ breakpoint: t }) => `(${this.type}-width: ${t / 16}em),${t}`)
          .filter((t, e, o) => o.indexOf(t) === e)),
        this.mediaQueries.forEach((t) => {
          const e = t.split(","),
            o = window.matchMedia(e[0]),
            a = e[1],
            s = this.оbjects.filter(({ breakpoint: t }) => t === a)
          o.addEventListener("change", () => {
            this.mediaHandler(o, s)
          }),
            this.mediaHandler(o, s)
        })
    }
    mediaHandler(t, e) {
      t.matches
        ? e.forEach((t) => {
            this.moveTo(t.place, t.element, t.destination)
          })
        : e.forEach(({ parent: t, element: e, index: o }) => {
            e.classList.contains(this.daClassname) && this.moveBack(t, e, o)
          })
    }
    moveTo(t, e, o) {
      e.classList.add(this.daClassname),
        "last" === t || t >= o.children.length ? o.append(e) : "first" !== t ? o.children[t].before(e) : o.prepend(e)
    }
    moveBack(t, e, o) {
      e.classList.remove(this.daClassname), void 0 !== t.children[o] ? t.children[o].before(e) : t.append(e)
    }
    indexInParent(t, e) {
      return [...t.children].indexOf(e)
    }
    arraySort(t) {
      "min" === this.type
        ? t.sort((t, e) =>
            t.breakpoint === e.breakpoint
              ? t.place === e.place
                ? 0
                : "first" === t.place || "last" === e.place
                  ? -1
                  : "last" === t.place || "first" === e.place
                    ? 1
                    : 0
              : t.breakpoint - e.breakpoint,
          )
        : t.sort((t, e) =>
            t.breakpoint === e.breakpoint
              ? t.place === e.place
                ? 0
                : "first" === t.place || "last" === e.place
                  ? 1
                  : "last" === t.place || "first" === e.place
                    ? -1
                    : 0
              : e.breakpoint - t.breakpoint,
          )
    }
  })("max").init()

  const d = document.querySelector(".hero"),
    h = document.getElementById("heroBg"),
    u = document.getElementById("heroTitle")

  if (d) {
    window.onscroll = () => {
      if (window.scrollY <= d.offsetHeight) {
        const t = window.scrollY,
          e = d.offsetHeight
        let o = t / e
        if (o > 100) o = 100
        h.style.transform = `translateY(${(o * e) / 2.8}px)`
        u.style.transform = `translateY(${(o * e) / 4}px)`
      }
    }

    document.addEventListener("click", async (t) => {
      if (t.target.closest(".copy-ca-btn")) {
        try {
          const e = t.target.closest(".copy-ca-btn").previousElementSibling.textContent.trim()
          await navigator.clipboard.writeText(e)
          alert("Address copied successfully")
        } catch (t) {
          console.error("Error copying address:", t)
          alert("Failed to copy address. Please try again.")
        }
      }
    })
  }

  const m = document.querySelectorAll(".pl-func"),
    g = document.querySelectorAll(".pr-func")
  let f

  function p() {
    f = window.innerWidth < 1450 ? 15 : (window.innerWidth - 1420) / 2
    if (m.length) {
      m.forEach((t) => {
        t.style.paddingLeft = f + "px"
      })
    }
    if (g.length) {
      g.forEach((t) => {
        t.style.paddingRight = f + "px"
      })
    }
  }

  p()
  document.body.onresize = p
  window.FLS = !1

  if (!document.documentElement.classList.contains("loading")) {
    window.addEventListener("load", () => {
      setTimeout(() => {
        document.documentElement.classList.add("loaded")
      }, 0)
    })
  }

  if (document.querySelector(".icon-menu")) {
    document.addEventListener("click", (t) => {
      if (o && t.target.closest(".icon-menu")) {
        if (document.documentElement.classList.contains("lock")) {
          a(500)
        } else {
          s(500)
        }
        document.documentElement.classList.toggle("menu-open")
      }
    })
  }

  // Função de navegação
  function handleNavigation() {
    function handleEvent(e) {
      if ("click" === e.type) {
        const o = e.target
        if (o.closest("[data-goto]")) {
          const a = o.closest("[data-goto]"),
            s = a.dataset.goto ? a.dataset.goto : "",
            c = !!a.hasAttribute("data-goto-header"),
            r = a.dataset.gotoSpeed ? a.dataset.gotoSpeed : 500,
            l = a.dataset.gotoTop ? Number.parseInt(a.dataset.gotoTop) : 0

          if (t.fullpage) {
            const e = document.querySelector(`${s}`).closest("[data-fp-section]"),
              o = e ? +e.dataset.fpId : null
            if (null !== o) {
              t.fullpage.switchingSection(o)
              if (document.documentElement.classList.contains("menu-open")) {
                n()
              }
            }
          } else {
            i(s, c, r, l)
          }
          e.preventDefault()
        }
      } else if ("watcherCallback" === e.type && e.detail) {
        const t = e.detail.entry,
          o = t.target
        if ("navigator" === o.dataset.watch) {
          document.querySelector("[data-goto]._navigator-active")
          let e
          if (o.id && document.querySelector(`[data-goto="#${o.id}"]`)) {
            e = document.querySelector(`[data-goto="#${o.id}"]`)
          } else if (o.classList.length) {
            for (let t = 0; t < o.classList.length; t++) {
              const a = o.classList[t]
              if (document.querySelector(`[data-goto=".${a}"]`)) {
                e = document.querySelector(`[data-goto=".${a}"]`)
                break
              }
            }
          }
          if (t.isIntersecting) {
            if (e) e.classList.add("_navigator-active")
          } else {
            if (e) e.classList.remove("_navigator-active")
          }
        }
      }
    }

    document.addEventListener("click", handleEvent)
    document.addEventListener("watcherCallback", handleEvent)

    if (e()) {
      let t
      if (document.querySelector(`#${e()}`)) {
        t = `#${e()}`
      } else if (document.querySelector(`.${e()}`)) {
        t = `.${e()}`
      }
      if (t) {
        i(t, !0, 500, 20)
      }
    }
  }

  handleNavigation()

  // Função para criar partículas flutuantes
  function createFloatingParticles(containerId, particleCount = 20) {
    const container = document.getElementById(containerId)
    if (!container) return

    for (let i = 0; i < particleCount; i++) {
      const particle = document.createElement("div")
      particle.className = "particle"
      particle.style.left = Math.random() * 100 + "%"
      particle.style.animationDelay = Math.random() * 6 + "s"
      particle.style.animationDuration = Math.random() * 3 + 4 + "s"
      container.appendChild(particle)
    }
  }

  // Função para criar cristais flutuantes
  function createFloatingCrystals(containerId, crystalCount = 15) {
    const container = document.getElementById(containerId)
    if (!container) return

    for (let i = 0; i < crystalCount; i++) {
      const crystal = document.createElement("div")
      crystal.className = "crystal"
      crystal.style.left = Math.random() * 100 + "%"
      crystal.style.animationDelay = Math.random() * 10 + "s"
      crystal.style.animationDuration = Math.random() * 5 + 8 + "s"
      container.appendChild(crystal)
    }
  }

  // Efeito de cursor com aura
  function createCursorAura() {
    const cursor = document.createElement("div")
    cursor.className = "cursor-aura"
    cursor.style.cssText = `
        position: fixed;
        width: 20px;
        height: 20px;
        background: radial-gradient(circle, rgba(26, 198, 77, 0.6) 0%, transparent 70%);
        border-radius: 50%;
        pointer-events: none;
        z-index: 9999;
        mix-blend-mode: screen;
        transition: transform 0.1s ease;
    `
    document.body.appendChild(cursor)

    document.addEventListener("mousemove", (e) => {
      cursor.style.left = e.clientX - 10 + "px"
      cursor.style.top = e.clientY - 10 + "px"
    })

    // Aumentar o cursor ao passar sobre elementos interativos
    const interactiveElements = document.querySelectorAll("a, button, [data-goto]")
    interactiveElements.forEach((el) => {
      el.addEventListener("mouseenter", () => {
        cursor.style.transform = "scale(2)"
        cursor.style.background = "radial-gradient(circle, rgba(26, 198, 77, 0.8) 0%, transparent 70%)"
      })
      el.addEventListener("mouseleave", () => {
        cursor.style.transform = "scale(1)"
        cursor.style.background = "radial-gradient(circle, rgba(26, 198, 77, 0.6) 0%, transparent 70%)"
      })
    })
  }

  // Efeito de ondas ao clicar
  function createClickWaves() {
    document.addEventListener("click", (e) => {
      const wave = document.createElement("div")
      wave.style.cssText = `
            position: fixed;
            left: ${e.clientX - 25}px;
            top: ${e.clientY - 25}px;
            width: 50px;
            height: 50px;
            border: 2px solid rgba(26, 198, 77, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            animation: click-wave 0.6s ease-out forwards;
        `

      // Adicionar keyframe se não existir
      if (!document.querySelector("#click-wave-style")) {
        const style = document.createElement("style")
        style.id = "click-wave-style"
        style.textContent = `
                @keyframes click-wave {
                    0% {
                        transform: scale(0);
                        opacity: 1;
                    }
                    100% {
                        transform: scale(4);
                        opacity: 0;
                    }
                }
            `
        document.head.appendChild(style)
      }

      document.body.appendChild(wave)

      setTimeout(() => {
        wave.remove()
      }, 600)
    })
  }

  // Efeito de brilho aleatório nas imagens
  function createRandomGlows() {
    const images = document.querySelectorAll(".cat-aura img, .aura-glow img")

    setInterval(() => {
      const randomImage = images[Math.floor(Math.random() * images.length)]
      if (randomImage) {
        randomImage.style.filter = "drop-shadow(0 0 30px rgba(26, 198, 77, 0.8)) brightness(1.2)"
        setTimeout(() => {
          randomImage.style.filter = ""
        }, 1000)
      }
    }, 3000)
  }

  // Inicializar todos os efeitos quando a página carregar
  document.addEventListener("DOMContentLoaded", () => {
    // Criar partículas nas seções principais
    createFloatingParticles("heroParticles", 25)
    createFloatingCrystals("heroCrystals", 20)
    createFloatingParticles("joinParticles", 15)

    // Efeitos de cursor e clique
    createCursorAura()
    createClickWaves()

    // Brilhos aleatórios
    createRandomGlows()

    // Efeito de aura no scroll
    window.addEventListener("scroll", () => {
      const scrollPercent = window.scrollY / (document.body.scrollHeight - window.innerHeight)
      const auraElements = document.querySelectorAll(".aura-glow, .cat-aura")

      auraElements.forEach((el, index) => {
        const delay = index * 0.1
        const intensity = Math.sin(scrollPercent * Math.PI * 2 + delay) * 0.5 + 0.5
        el.style.filter = `drop-shadow(0 0 ${20 + intensity * 20}px rgba(26, 198, 77, ${0.3 + intensity * 0.4}))`
      })
    })
  })

  // Efeito especial para o tokenomics (animação do leopardo)
  const leopardElement = document.querySelector(".tokenomics__left-jeetta")
  if (leopardElement) {
    setInterval(() => {
      leopardElement.style.filter = "drop-shadow(0 0 40px rgba(26, 198, 77, 0.9)) saturate(1.3)"
      setTimeout(() => {
        leopardElement.style.filter = ""
      }, 500)
    }, 4000)
  }
})()
